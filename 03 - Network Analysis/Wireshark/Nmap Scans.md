Investigating Nmap: A Deep Dive into Packet Analysis
By: Subhan Ahmad Khan

Introduction
As Iâ€™ve been training for a SOC role, I realized that many people know how to run an Nmap scan, but we don't truly understand what that scan looks like to a defender. To bridge this gap, I set up a lab environment to capture and analyze the network "noise" generated by Nmap using Wireshark.

My goal was simple: If an attacker scans my network, what specific signatures am I looking for in the logs?

1. Analyzing the TCP Connect Scan (-sT)
When I ran a Connect scan, I noticed it was the "loudest" on the wire. Because I wasn't running it as root, Nmap was forced to complete the full 3-way handshake for every port.

My Observation: I saw a complete flow of SYN -> SYN, ACK -> ACK.

The Signature: In Wireshark, these packets usually have a window size larger than 1024, as the connection is fully established and ready to exchange data.

https://github.com/user-attachments/assets/9ff25066-34ae-4552-be9c-65e0eadb3b22

2. The SYN "Stealth" Scan (-sS)
Next, I analyzed the SYN scan. This is the Nmap default for a reasonâ€”itâ€™s faster and avoids completing the connection.

My Observation: The scanner sends a SYN, waits for the SYN, ACK from the target, but then immediately kills the connection with a RST (Reset).

The Signature: These probes are distinct because the TCP window size is usually â‰¤ 1024 bytes. We are looking for "half-open" connections that never result in actual data transfer.

[Insert your SYN Scan GIF here]

3. The UDP Scan (-sU)
UDP was the trickiest to analyze because there is no handshake. Itâ€™s a "fire and forget" protocol.

My Observation: When I scanned a closed UDP port, the target machine responded with an ICMP Type 3 (Destination Unreachable).

Deep Dive: By drilling down into the ICMP packet details in Wireshark, I could see the original UDP request encapsulated inside the error message. This is how I confirmed which specific port triggered the error.

[Insert your UDP Scan GIF here]

ðŸ’¡ Lessons Learned
Handshakes Matter: I learned that the presence of an RST packet immediately after a SYN, ACK is a huge red flag for a SYN scan.

Filter Proficiency: Understanding the difference between tcp.flags == 0x002 (pure SYN) and tcp.flags == 0x012 (SYN/ACK) is essential for quickly filtering through thousands of packets.

Context is King: You canâ€™t just look at one packet; you have to look at the "conversation" to see if a port is truly open or just being probed.

ðŸš§ Limitations & Next Steps
While manual analysis in Wireshark is great for learning, it isn't scalable in a high-traffic SOC environment. Here is how I plan to improve this workflow:

Automation with Python (Scapy): Manually clicking through packets takes too long. My next goal is to write a Python script using the Scapy library to automatically flag IP addresses that send more than X amount of SYN packets without a following ACK.

SIEM Integration: I need to practice forwarding these packet captures into a SIEM like Splunk or ELK, where I can create dashboards to visualize "Top Scanned Ports" and "Most Active Scanners."

Encrypted Traffic: Nmap can't see inside encrypted tunnels easily. I want to explore how scan patterns change when conducted over a VPN or encrypted proxy.

Final Filter Cheat Sheet
I used these filters throughout my analysis to cut through the noise:

Connect Scan: tcp.flags.syn==1 and tcp.flags.ack==0 and tcp.window_size > 1024

SYN Scan: tcp.flags.syn==1 and tcp.flags.ack==0 and tcp.window_size <= 1024

UDP Scan: icmp.type==3 and icmp.code==3
