Investigating Nmap: A Deep Dive into Packet Analysis
By: Subhan Ahmad Khan

## Introduction
As Iâ€™ve been training for a SOC role, I realized that many people know how to run an Nmap scan, but we don't truly understand what that scan looks like to a defender. To bridge this gap, I set up a lab environment to capture and analyze the network "noise" generated by Nmap using Wireshark.

My goal was simple: If an attacker scans my network, what specific signatures am I looking for in the logs?

## 1. Analyzing the TCP Connect Scan (-sT)
When I ran a Connect scan, I noticed it was the "loudest" on the wire. Because I wasn't running it as root, Nmap was forced to complete the full 3-way handshake for every port.

My Observation: I saw a complete flow of SYN -> SYN, ACK -> ACK.

The Signature: In Wireshark, these packets usually have a window size larger than 1024, as the connection is fully established and ready to exchange data.
However, it is not always easy to spot the given patterns in big capture files. Therefore we need to use a generic filter to view the initial anomaly patterns, and then it will be easier to focus on a specific traffic point. 

https://github.com/user-attachments/assets/d36e0318-37d2-4f94-86eb-7119dbb00c48



## 2. The SYN "Stealth" Scan (-sS)
Next, I analyzed the SYN scan. This is the Nmap default for a reasonâ€”itâ€™s faster and avoids completing the connection.

My Observation: The scanner sends a SYN, waits for the SYN, ACK from the target, but then immediately kills the connection with a RST (Reset).

The Signature: These probes are distinct because the TCP window size is usually â‰¤ 1024 bytes. We are looking for "half-open" connections that never result in actual data transfer.


https://github.com/user-attachments/assets/211cd527-ae73-4849-ab11-73654da76c63


## 3. The UDP Scan (-sU)
UDP was the trickiest to analyze because there is no handshake. Itâ€™s a "fire and forget" protocol.

My Observation: When I scanned a closed UDP port, the target machine responded with an ICMP Type 3 (Destination Unreachable).

Deep Dive: By drilling down into the ICMP packet details in Wireshark, I could see the original UDP request encapsulated inside the error message. This is how I confirmed which specific port triggered the error.


https://github.com/user-attachments/assets/69865527-da48-4372-bf06-d22a44353660


## ðŸ’¡ Lessons Learned
Handshakes Matter: I learned that the presence of an RST packet immediately after a SYN, ACK is a huge red flag for a SYN scan.

Filter Proficiency: Understanding the difference between tcp.flags == 0x002 (pure SYN) and tcp.flags == 0x012 (SYN/ACK) is essential for quickly filtering through thousands of packets.

Context is King: You canâ€™t just look at one packet; you have to look at the "conversation" to see if a port is truly open or just being probed.

## ðŸš§ Limitations & Next Steps
While manual analysis in Wireshark is great for learning, it isn't scalable in a high-traffic SOC environment. Here is how I plan to improve this workflow:

Automation with Python (Scapy): Manually clicking through packets takes too long. My next goal is to write a Python script using the Scapy library to automatically flag IP addresses that send more than X amount of SYN packets without a following ACK.

SIEM Integration: I need to practice forwarding these packet captures into a SIEM like Splunk or ELK, where I can create dashboards to visualize "Top Scanned Ports" and "Most Active Scanners."

Sometimes the adversary can run the SYN SCAN knowing the RST flag immediately after is going to be detected so they instead stop the connection by not responding at all... We then need to make special rules about this to take care of it.  


## Final Filter Cheat Sheet
I used these filters throughout my analysis to cut through the noise:

Connect Scan: tcp.flags.syn==1 and tcp.flags.ack==0 and tcp.window_size > 1024

SYN Scan: tcp.flags.syn==1 and tcp.flags.ack==0 and tcp.window_size <= 1024

UDP Scan: icmp.type==3 and icmp.code==3
